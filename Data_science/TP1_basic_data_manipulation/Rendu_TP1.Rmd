---
title: "Rendu Travaux Pratiques 1"
output:
  html_document: default
  html_notebook: default
---

** **

#### Règles de rendu

* Chaque TP donne lieu à un bref compte-rendu portant sur certaines questions posées dans l'énoncé du TPs.

* Le compte-rendu doit être complété à partir du texte de l'énoncé. Les codes R doivent être inclus dans le texte du compte-rendu (menu **Insert**) et commentés avec précision. **Les commentaires compteront pour une part importante dans la note**.

* Le compte-rendu doit être déposé **sur TEIDE à la fin de la séance de TP**. Les rendus en retard seront fortement pénalisés. Il est 

* Le compte-rendu doit être déposé **sur TEIDE au format HTML uniquement**. Utiliser la fonction **Preview** ou **knitr** du menu de rstudio pour obtenir le document au format souhaité. **Les fichiers "source" (Rmd) ne seront pas acceptés par les correcteurs**.



** **


#### Exercice 1: Vecteurs, matrices, listes et fonctions 

* On considère la suite finie $x_i = \sin(i)$, $i = 1,\dots,n = 123$. Combien de termes de cette suite sont-ils plus grands que 1/2 ? 

```{r}
  # comment 1 : Ultimate Question of Life
  help(sin)
  #on somme les booléens valant TRUE (donc 1) quand le sin du nombre est supérieur à 0.5
  sum(sapply(1:123,sin)>0.5)
```



* On effectue un million de tirages de valeurs entre 1 et 12 de sorte que la probabilité de chaque valeur $i$ est proportionnelle à $1/i$. Calculer la fréquence de nombre pairs.

```{r}
  # on donne au paramètre prob un vecteur qui contient les poids (la somme n'est pas forcément égale à 1) des nombres
  # ainsi il nous suffit d'appliquer la fonction inverse, sans se préoccuper du coefficient de normalisation
  x <- sample(1:12, 1000000, replace = TRUE, prob=sapply(1:12, FUN = function(i){1/i}))

  # on peut faire une moyenne des booléens qui valent 1 quand un nombre est pair, 0 sinon
  # Cette moyenne correspond donc exactement à la fréquence des nombres pairs dans x
  mean( x %% 2 ==0 )
```


* À partir du tableau de données **BreastCancer** du package *mlbench*, créer une matrice où toutes les lignes du tableau ayant des valeurs manquantes sont enlevées. 


```{r}
  library('mlbench')

  # charge les données en mémoire
  data(BreastCancer)

  # crée une matrice à partir du tableau de données "BreastCancer"
  mat_bc <- data.matrix(BreastCancer)
  
  # création d'un vecteur logique qui indique s'il manque une donnée à la ligne 
  boo_na <- apply(mat_bc, MARGIN = 1, anyNA)
  mat_bc_no_na <- mat_bc[!boo_na, ]
  
  # mat_bc_no_na contient toutes les lignes de mat_bc dont les données étaient complètes
  sans_na = dim(mat_bc_no_na)[1]
  avec_na = dim(mat_bc)[1]
  cat("Nombre de lignes dont il manquait une donnée: ", avec_na-sans_na)
```

* Créer une fonction `f(x)` prenant en entrée un vecteur numérique et retournant une liste contenant la moyenne et l'ecart type de `x` (fonctions `mean`, `sd`).  Commenter et compléter le code suivant.


```{r}
f <-function(x){
  # function qui retourne une liste contentant dans mean la moyenne et dans sd l'écart-type
  
  # on vérifie que le paramètre x est bien un vecteur numérique
  if (!is.numeric(x)) stop("x must be numeric. \n")
  
  # on crée la liste que l'on va retourner contenant la moyenne et l'écart-type
  object <- list(mean=mean(x), sd=sd(x))
  return(object)
}
```


#### Exercice 2: Vecteurs, matrices, listes et fonctions 

* Calculer les valeurs propres de la matrice **M** definie ci-dessous.

```{r}
  M <- matrix(c(5, -1, -1, -1, 3, 1, -1, 1, 2), nrow  = 3)
  obj = eigen(M)
  obj$values
```

* Calculer la matrice $M^{-1}$ et vérifier que $M^{-1} = U \Lambda^{-1} U^T$, où $\Lambda$ désigne une matrice diagonale contenant les valeurs propres de $M$ et $U$ une matrice unitaire correspondant aux vecteurs propres de $M$.

```{r}
Minv=solve(M)
Lambda = diag(obj$values)
Linv = solve(Lambda)
U = obj$vectors

# on vérifie naïvement l'égalité
Minv == U%*%Linv%*%t(U)

# Pour vérifier l'égalité sur des flottants, on vérifie en fait que leur différence est négligeable
# Car on ne peut pas tester l'égalité des flottants en informatique du fait de leur représentation
# et des approximations
Minv - U%*%Linv%*%t(U) < 10**-15

```


#### Exercice 3 : Distance de mahalanobis 


* Calculer la valeur $d_C^2((3,2),0)$ pour la matrice ${\bf C}$ définie ci-dessous

```{r}
  C <- matrix(c(5, -1, -1, 1), nrow  = 2)
  x=c(3,2)
  # on utilise la formule de la distance
  d = sqrt(t(x)%*%solve(C)%*%x)
  d
```


* Pour toute ligne $i$ de la matrice `x` ci-dessous,  calculer un vecteur $(d_1, d_2)$ dont les composantes sont le carré de la distance de Mahalanobis séparant ${\bf x}_i$ du centre de la classe 1 et de la classe 2 respectivement.

```{r}
  # matrice de covariance de la classe 1
  C1 <- matrix(c(5, -1, -1, 1), nrow  = 2, byrow = T)

  # matrice de covariance de la classe 2
  C2 <- matrix(c(3, 1, 1, 2), nrow = 2, byrow = T)
  
  n <- 1000
  class <- rep(1:2, each = n)
  
  x1 <- MASS::mvrnorm(n, mu = c(4,0), C1)
  x2 <- MASS::mvrnorm(n, mu = c(0,4), C2)
  
  x <- rbind(x1, x2)
  
  #on calcule les deux centres des distributions
  m1 = apply(x1, MARGIN = 2, FUN = mean)
  m2 = apply(x2, MARGIN = 2, FUN = mean)
  
  #on définit les fonctions calculant les distances pour les deux distributions
  #cette distance et en fait celle au carré, mais cela ne change rien pour les comparaisons futures
  d1 <- function(xi){
    d1=t(xi-m1)%*%solve(C1)%*%(xi-m1)
    return(d1)}
  
  d2 <- function(xi){
    d2=t(xi-m2)%*%solve(C2)%*%(xi-m2)
    return(d2)}
  
  #on calcule un vecteur logique qui indique pour tous les éléments de x s'ils ont été classés dans la classe 1
  bool_class1 = apply(x,MARGIN=1,d1) < apply(x,MARGIN=1,d2)
```



* On souhaite classer l'élément ${\bf x}_i$ dans la classe 1 si 

$$
d_{C_1}({\bf x}_i , m_1) < d_{C_2}({\bf x}_i , m_2)
$$
et dans la classe 2 sinon.  Calculer le pourcentage d'observations qui ont été bien classées par cette procédure.
```{r}
  true1 = sum(bool_class1[class == 1])
  false1 = 1000-true1
  cat("Nombre de membres de la classe 1 qui ont été classés dans 1:",true1,"\n")
  false2 = sum(bool_class1[class == 2])
  true2 = 1000 - false2
  cat("Nombre de membres de la classe 2 qui ont été classés dans 1:",false2,"\n")
  
  cat("Pourcentage de réussite:",(true1+true2)/2000)
```



